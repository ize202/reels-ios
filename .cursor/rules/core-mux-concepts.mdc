---
description: Core Mux concepts; you should include this in most projects when working with Mux
globs: 
alwaysApply: false
---
# Stream videos in five minutes
Upload and play back your video files in your application using Mux in five minutes or less.
## 1. Get an API Access Token

The Mux Video API uses a token key pair that consists of a **Token ID** and **Token Secret** for authentication. If you haven't already, generate a new Access Token in the [Access Token settings](mdc:https:/dashboard.mux.com/settings/access-tokens) of your Mux account dashboard.

<Image src="/docs/images/settings-api-access-tokens-2x.png" width={2404} height={526} alt="Mux access token settings" />

You'll be presented with a form to create your new Access Token.

<Image src="/docs/images/new-access-token.png" width={545} height={233} alt="Mux Video access token permissions" />

* **Access Tokens** belong to an **Environment** â€” a container for the various Access Tokens, Signing Keys, and assets that you'll come to add to Mux. For this guide, you can keep the **Production** environment selected.
* **Access Tokens** can have varying permissions to control what kinds of changes they have the ability to make. For this guide, your **Access Token** should have Mux Video **Read** and **Write** permissions.
* You can give your **Access Token** an internal-only name like "Onboarding" so you know where you've used it within your application.

Now, click the **Generate token** button.

You'll be presented with your new **Access Token ID** and **Secret Key**.

<Image src="/docs/images/settings-generated-access-token.png" width={692} height={549} alt="Mux access token environment" />

Once you have your new **Access Token ID** and **Secret Key**, you're ready to upload your first video.

## 2. POST a video

Videos stored in Mux are called <ApiRefLink product="video" slug="assets">assets</ApiRefLink>. To create your first video asset, you need to send a <ApiRefLink product="video" slug="operation/create-asset">POST request to the /assets endpoint</ApiRefLink> and set the `input` value to the URL of a video file that's accessible online.

Here are a few demo videos you can use that are stored on common cloud storage services:

* Amazon S3: https://muxed.s3.amazonaws.com/leds.mp4
* Google Drive: https://drive.google.com/uc?id=13ODlJ-Dxrd7aJ7jy6lsz3bwyVW-ncb3v
* Dropbox: https://www.dropbox.com/scl/fi/l2sm1zyk6pydtosk3ovwo/get-started.mp4?rlkey=qjb34b0b7wgjbs5xj9vn4yevt\&dl=0

To start making API requests to Mux, you might want to install one of our officially supported API SDKs. These are lightweight wrapper libraries that use your API credentials to make authenticated HTTP requests to the Mux API.

```elixir

# mix.exs
def deps do
  [
    {:mux, "~> 1.8.0"}
  ]
end

```

```go

go get github.com/muxinc/mux-go

```

```node

# npm
npm install @mux/mux-node --save

# yarn
yarn add @mux/mux-node

```

```php

# composer.json
{
    "require": {
        "muxinc/mux-php": ">=0.0.1"
    }
}

```

```python

# Via pip
pip install git+https://github.com/muxinc/mux-python.git

# Via source
git checkout https://github.com/muxinc/mux-python.git
cd mux-python
python setup.py install --user

```

```ruby

gem 'mux_ruby'

```



<Callout type="info">
  For an example of how to make API Requests from your local environment, see the [Make API Requests](mdc:docs/core/make-api-requests) guide.
</Callout>

<CodeExamples product="video" example="createAsset" />

The response will include an **Asset ID** and a **Playback ID**.

* Asset IDs are used to manage assets using `api.mux.com` (e.g. to read or delete an asset).
* <ApiRefLink product="video" slug="playback-ids">Playback IDs</ApiRefLink> are used to stream an asset to a video player through `stream.mux.com`. You can add multiple playback IDs to an asset to create playback URLs with different viewing permissions, and you can delete playback IDs to remove access without deleting the asset.

```json
{
  "data": {
    "status": "preparing",
    "playback_ids": [
      {
        "policy": "public",
        "id": "TXjw00EgPBPS6acv7gBUEJ14PEr5XNWOe"
      }
    ],
    "video_quality": "basic",
    "mp4_support": "none",
    "master_access": "none",
    "id": "01itgOBvgjAbES7Inwvu4kEBtsQ44HFL6",
    "created_at": "1607876845"
  }
}
```

<Callout type="info">
  Mux does not store the original file in its exact form, so if your original quality files are important to you, don't delete them after submitting them to Mux.
</Callout>

## 3. Wait for \`ready\`

As soon as you make the `POST` request, Mux begins downloading and processing the video. For shorter files, this often takes just a few seconds. Very large files over poor connections may take a few minutes (or longer).

When the video is ready for playback, the asset `status` changes to `ready`. You should wait until the asset status is `ready` before you attempt to play the video.

The best way to be notified of asset status updates is via **webhooks**. Mux can send a webhook notification as soon as the asset is ready. See the [webhooks guide](mdc:docs/core/listen-for-webhooks) for details.

If you can't use webhooks for some reason, you can manually **poll** the <ApiRefLink product="video" slug="operation/get-asset">asset API</ApiRefLink> to see asset status. Note that this only works at low volume. Try this example:

## Try an example request

<CodeExamples product="video" example="retrieveAsset" />

Please don't poll this API more than once per second.

## 4. Watch your Video

To play back an asset, create a playback URL using the `PLAYBACK_ID` you received when you created the asset.

```curl
https://stream.mux.com/{PLAYBACK_ID}.m3u8
```

## Preview in a player

```android

implementation 'com.google.android.exoplayer:exoplayer-hls:2.X.X'

// Create a player instance.
SimpleExoPlayer player = new SimpleExoPlayer.Builder(context).build();
// Set the media item to be played.
player.setMediaItem(MediaItem.fromUri("https://stream.mux.com/{PLAYBACK_ID}.m3u8"));
// Prepare the player.
player.prepare();

```

```html

<script src="https://cdn.jsdelivr.net/npm/@mux/mux-player" defer></script>

<mux-player
  playback-id="{PLAYBACK_ID}"
  metadata-video-title="Test video title"
  metadata-viewer-user-id="user-id-007"
></mux-player>

```

```react

import MuxPlayer from '@mux/mux-player-react';

export default function VideoPlayer() {
  return (
    <MuxPlayer
      playbackId="{PLAYBACK_ID}"
      metadata={{
        video_id: "video-id-54321",
        video_title: "Test video title",
        viewer_user_id: "user-id-007",
      }}
    />
  );
}

```

```swift

import SwiftUI
import AVKit

let playbackID = "qxb01i6T202018GFS02vp9RIe01icTcDCjVzQpmaB00CUisJ4"

struct ContentView: View {

    private let player = AVPlayer(
        url: URL.makePlaybackURL(
            playbackID: playbackID
        )
    )

    var body: some View {
        //  VideoPlayer comes from SwiftUI
        //  Alternatively, you can use AVPlayerLayer or AVPlayerViewController
        VideoPlayer(player: player)
            .onAppear() {
                player.play()
            }
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}

extension URL {
    static func makePlaybackURL(
        playbackID: String
    ) -> URL {
        guard let baseURL = URL(
            string: "https://stream.mux.com"
        ) else {
            preconditionFailure("Invalid base URL string")
        }

        guard let playbackURL = URL(
            string: "\(playbackID).m3u8",
            relativeTo: baseURL
        ) else {
            preconditionFailure("Invalid playback URL component")
        }

        return playbackURL
    }
}

```



See the [playback guide](mdc:docs/guides/play-your-videos) for more information about how to integrate with a video player.

## Preview with `stream.new`

[Stream.new](mdc:https:/stream.new) is an open source project by Mux that allows you to add a video and get a shareable link to stream it.

Go to `stream.new/v/{PLAYBACK_ID}` to preview your video streaming. This URL is shareable and automatically generated using the video playback ID. Copy the link below and open it in a browser to view your video.

```
https://stream.new/v/{PLAYBACK_ID}
```

After you have everything working [integrate Mux Data](mdc:docs/guides/track-your-video-performance) with your player for monitoring playback performance.

## 5. Manage your Mux assets

After you have assets created in your Mux environment, you may find some of these other endpoints handy:

* <ApiRefLink product="video" slug="operation/create-asset">Create an asset</ApiRefLink>
* <ApiRefLink product="video" slug="operation/list-assets">List assets</ApiRefLink>
* <ApiRefLink product="video" slug="operation/get-asset">Retrieve an asset</ApiRefLink>
* <ApiRefLink product="video" slug="operation/delete-asset">Delete an asset</ApiRefLink>
* <ApiRefLink product="video" slug="operation/get-asset-input-info">Retrieve asset input info</ApiRefLink>
* <ApiRefLink product="video" slug="operation/create-asset-playback-id">Create asset playback ID</ApiRefLink>
* <ApiRefLink product="video" slug="operation/get-asset-playback-id">Retrieve asset playback ID</ApiRefLink>
* <ApiRefLink product="video" slug="operation/delete-asset-playback-id">Delete asset playback ID</ApiRefLink>
* <ApiRefLink product="video" slug="operation/update-asset-mp4-support">Update MP4 support on asset</ApiRefLink>
* <ApiRefLink product="video" slug="operation/update-asset-master-access">Update master access on asset</ApiRefLink>
* <ApiRefLink product="video" slug="operation/create-asset-track">Update asset track</ApiRefLink>
* <ApiRefLink product="video" slug="operation/delete-asset-track">Delete an asset track</ApiRefLink>

More Video methods and descriptions are available at the <ApiRefLink product="video" slug="">API Docs</ApiRefLink>.

# Next Steps

<GuideCard
  title="Play your videos"
  description="Set up your iOS application, Android application or web application to start playing your Mux assets"
  links={[
    {title: "Read the guide", href: "/docs/guides/play-your-videos"},
  ]}
/>

<GuideCard
  title="Preview your video"
  description="Now that you have Mux assets, build rich experiences into your application by previewing your videos with Thumbnails and Storyboards"
  links={[
    {title: "Read the guide", href: "/docs/guides/get-images-from-a-video"},
  ]}
/>

<GuideCard
  title="Integrate Mux Data"
  description="Add the Mux Data SDK to your player and start collecting playback performance metrics."
  links={[
    {title: "Read the guide", href: "/docs/guides/track-your-video-performance"},
  ]}
/>


# Make API requests
Learn how to work with Mux's API through HTTP requests.
## HTTP basic auth

| Term         | Description                                            |
| :----------- | :----------------------------------------------------- |
| Token ID     | access token ID, the "username" in HTTP basic auth     |
| Token secret | access token secret, the "password" in HTTP basic auth |

Every request to the API is authenticated via an [Access Token](mdc:https:/dashboard.mux.com/settings/access-tokens), which includes the ID and the secret key. You can think of the Access Tokenâ€™s ID as its username and secret as the password. Mux only stores a hash of the secret, not the secret itself. If you lose the secret key for your access token, Mux cannot recover it; you will have to create a new Access Token. If the secret key for an Access Token is leaked you should revoke that Access Token on the settings page: https://dashboard.mux.com/settings/access-tokens.

Note that in order to access the settings page for access tokens you must be an admin on the Mux organization.

API requests are authenticated via HTTP Basic Auth, where the username is the Access Token ID, and the password is the Access Token secret key. Due to the use of Basic Authentication and because doing so is just a Really Good Ideaâ„¢, all API requests must made via HTTPS (to `https://api.mux.com`).

<Callout type="warning" title="Watch out for mismatched tokens and environments">
  Access tokens are scoped to an environment, for example: a development token cannot be used in requests to production. Verify the intended environment when creating an access token.
</Callout>

This is an example of authenticating a request with cURL, which automatically handles HTTP Basic Auth. If you run this request yourself it will not work, you should replace the Access Token ID (`44c819de-4add-4c9f-b2e9-384a0a71bede`) and secret (`INKxCoZ+cX6l1yrR6vqzYHVaeFEcqvZShznWM1U/No8KsV7h6Jxu1XXuTUQ91sdiGONK3H7NE7H`) in this example with your own credentials.

```shell
curl https://api.mux.com/video/v1/assets \
  -H "Content-Type: application/json" \
  -X POST \
  -d '{ "input": "https://muxed.s3.amazonaws.com/leds.mp4", "playback_policy": "public", "video_quality": "basic" }' \
  -u 44c819de-4add-4c9f-b2e9-384a0a71bede:INKxCoZ+cX6l1yrR6vqzYHVaeFEcqvZShznWM1U/No8KsV7h6Jxu1XXuTUQ91sdiGONK3H7NE7H
```

HTTP basic auth works by base64 encoding the username and password in an `Authorization` header on the request.

Specifically, the header looks something like this:

```bash
'Authorization': 'Basic base64(MUX_TOKEN_ID:MUX_TOKEN_SECRET)'
```

1. The access token ID and secret are concatenated with a `:` and the string is base64 encoded.
2. The value for the `Authorization` header is the string `Basic` plus a space ` ` followed by the base64 encoded result from Step 1.

In the cURL example above, the cURL library is taking care of the base64 encoding and setting the header value internally. The HTTP library you use in your server-side language will probably have something similar for handling basic auth. You should be able to pass in the `username` (Access Token ID) and `password` (Access Token secret) and the library will handle the details of formatting the header.

## Access token permissions

<Callout type="success" title="Full Permissions">
  If you're just getting started with Mux Video, use Read and Write.
</Callout>

If you are creating or modifying resources with Mux Video then you need **Read** and **Write** permissions. This includes things like:

* Creating new assets
* Creating direct uploads
* Creating new live streams

If you need to create signed tokens for secure video playback, your access token needs **System** write permissions. Learn more about [secure video playback](mdc:docs/guides/secure-video-playback) and <ApiRefLink product="system" slug="tag/signing-keys">signing keys</ApiRefLink>.

<Image src="/docs/images/access-token-permissions-video.png" width={760} height={376} alt="Mux Video access token permissions" sm />

If your code is not creating anything and only doing `GET` requests then you can restrict the access token to **Read** only.

## CORS and client side API requests

Mux API endpoints do not have CORS headers, which means if you try to call the Mux API from the browser you will get an error:

<Callout type="error" title="CORS Error in Browser">
  request has been blocked by CORS policy: Response to preflight request doesn't pass access control check: No 'Access-Control-Allow-Origin' header is present on the requested resource.
</Callout>

This is expected. Although making API requests directly from the browser or your mobile app would be convenient, it leaves a massive security hole in your application by the fact that your client side code would contain your API keys. Anyone who accesses your application would have the ability to steal your API credentials and make requests to Mux on your behalf. An attacker would be able to gain full control of your Mux account.

Mux API Credentials should never be stored in a client application. All Mux API calls should be made from a trusted server.

Instead of trying to make API requests from the client, the flow that your application should follow is:

1. Client makes a request to your server
2. Your server makes an authenticated API request to Mux
3. Your server saves whatever it needs in your database
4. Your server responds to the client with only the information that the client needs. For example, with live streaming that's the stream key for a specific stream, for uploads that's just the direct upload URL

## Using Mux with serverless functions

Serverless functions are a great way to add pieces of secure server-side code to your client heavy application. Examples of services that help you run serverless functions are:

* [AWS Lambda](mdc:https:/aws.amazon.com/lambda)
* [Firebase Cloud Functions](mdc:https:/firebase.google.com/docs/functions)
* [Cloudflare Workers](mdc:https:/workers.cloudflare.com)
* [Vercel Functions](mdc:https:/vercel.com/docs/functions)
* [Netlify Functions](mdc:https:/docs.netlify.com/functions/overview)

The basic idea behind serverless functions is that you can write a bit of server code and deploy it to run on these platforms. Your client application can make requests to these endpoints to perform specific actions. Below is an example from [with-mux-video](mdc:https:/github.com/vercel/next.js/blob/canary/examples/with-mux-video/pages/api/upload.js) of a serverless function endpoint that makes an API call to create a Mux Direct Upload.

```js
// pages/api/upload.js
// see: https://github.com/vercel/next.js/tree/canary/examples/with-mux-video
import Mux from '@mux/mux-node';

const mux = new Mux();

export default async function uploadHandler(req, res) {
  const { method } = req;

  switch (method) {
    case 'POST':
      try {
        const upload = await mux.video.uploads.create({
          new_asset_settings: { playback_policy: ['public'], video_quality: 'basic' },
          cors_origin: '*',
        });
        res.json({
          id: upload.id,
          url: upload.url,
        });
      } catch (e) {
        console.error('Request error', e);
        res.status(500).json({ error: 'Error creating upload' });
      }
      break;
    default:
      res.setHeader('Allow', ['POST']);
      res.status(405).end(`Method ${method} Not Allowed`);
  }
}
```

## API rate limits

Mux Video implements a simple set of rate limits. Rate limits are set per account (not per environment). These rate limits exist for two reasons:

1. First, to protect you, or customers from runaway scripts or batch process - we don't want you to accidentally delete all your content, or run up a large bill if you're not expecting it.
2. Second, to ensure that there's always Mux infrastructure available when our customers need it, for example to start that critical live stream, or ingest that urgent video.

<Callout type="warning" title="Exceeding the rate limit">
  When the rate limit threshold is exceeded, the API will return a HTTP status code `429`.
</Callout>

### Video API

1. All Video API activities that include a `POST` request to `https://api.mux.com/video/` are rate limited to a sustained 1 request per second (RPS) with the ability to burst above this for short periods of time. This includes creating new <ApiRefLink product="video" slug="tag/assets">Assets</ApiRefLink>, <ApiRefLink product="video" slug="tag/live-streams">Live Streams</ApiRefLink>, and <ApiRefLink product="video" slug="tag/direct-uploads">Uploads</ApiRefLink>.

2. All other request methods are limited to 5 sustained requests per second (RPS) with the ability to burst above this for short periods of time. This includes `GET`, `PUT`, `PATCH`, & `DELETE` verbs. Examples include (but not limited to) requests for <ApiRefLink product="video" slug="operation/get-asset">retrieving an asset</ApiRefLink>, <ApiRefLink product="video" slug="operation/update-asset-mp4-support">updating mp4 support</ApiRefLink>, & <ApiRefLink product="video" slug="operation/list-delivery-usage">listing delivery usage</ApiRefLink>.

### Playback

There are no limits as to the number of viewers that your streams can have, all we ask is that you let us know if you're planning an event expected to receive more than 100,000 concurrent live viewers.

### Monitoring Data API

Requests against the <ApiRefLink product="data" slug="operation/list-monitoring-dimensions">Monitoring Data</ApiRefLink> APIs are rate limited to a sustained 1 request per second (RPS) with the ability to burst above this for short periods of time.

### General Data API

Requests against the all other <ApiRefLink product="data" slug="tag/video-views">General Data</ApiRefLink> APIs are rate limited to a sustained 5 request per second (RPS) with the ability to burst above this for short periods of time.


# Use a Mux SDK
Mux SDKs are available for a variety of languages and platforms.
Mux has API SDKs for several major languages. You are not required to use them, but these SDKs handle the details of authentication for you and make it a little nicer to send API requests to Mux; in languages with static typing or type hints, they also will help you form correct requests and reduce development time.

* [Node](mdc:docs/integrations/mux-node-sdk)
* [Python](mdc:docs/integrations/mux-python-sdk)
* [PHP](mdc:docs/integrations/mux-php-sdk)
* [Ruby](mdc:docs/integrations/mux-ruby-sdk)
* [Elixir](mdc:docs/integrations/mux-elixir-sdk)
* [Java](mdc:docs/integrations/mux-java-sdk)
* [C# and other .NET languages](mdc:docs/integrations/mux-csharp-sdk)


# Make API requests with Postman
In this guide you will learn how to fork, set up, and work with Mux's API collection using Postman's API interface.
## Fork the collection

We recommend [Postman](mdc:https:/postman.com) as a way to easily explore and interact with our API.

Similar to forking a repository on GitHub, forking a collection on Postman allows you to create a new instance of the collection.
Here, you can send requests, collaborate, and submit changes to the original collection.
Without forking the collection, the collection will be **read-only** and you will not be able to make requests unless you're a member of the workspace â€” even if the collection is public.

If you're already a Postman user, you can fork our [officially supported Postman collection](mdc:https:/www.postman.com/muxinc/workspace/mux-apis/overview?utm_campaign=postman-collab\&utm_medium=guide\&utm_source=mux) and add it to your workspace by clicking the button below.

You can then stay up to date with future changes to our API specification by pulling changes. More on that in the sections below.

[![Run in Postman](mdc:https:/run.pstmn.io/button.svg)](https://god.gw.postman.com/run-collection/18282356-97f1767e-f35a-4fca-b1c5-bf612e6f8e76?action=collection%2Ffork\&collection-url=entityId%3D18282356-97f1767e-f35a-4fca-b1c5-bf612e6f8e76%26entityType%3Dcollection%26workspaceId%3D2bcc854d-f831-4c9f-ac0a-3b4382f3a5cd)

## Basic authentication

| Term         | Description                                                |
| :----------- | :--------------------------------------------------------- |
| Token ID     | access token ID, the "username" in basic auth              |
| Token secret | access token secret key, the "password" in basic auth      |

## Set up credentials

Once you've created your access tokens via your [Mux account](mdc:https:/dashboard.mux.com/signup?type=video?utm_campaign=postman-collab\&utm_medium=guide\&utm_source=mux), you can input them into their respective fields under authorization.

<Image src="/docs/images/postman-auth.png" width={1217} height={723} alt="Basic authentication in Postman" />

## Environment variables

You can use [environment variables](mdc:https:/learning.postman.com/docs/sending-requests/variables/?utm_campaign=mux-collab\&utm_medium=site\&utm_source=mux) to store and reuse values â€” like your credentials â€”
across requests and collections. Variables can either be scoped to the environment or globally, available to all collections within a workspace.

To create environment variables, click the eye icon on the right-hand side of the collection and choose the scope you want your credentials to apply to.

<Image src="/docs/images/postman-env-variables.png" width={1217} height={723} alt="Environment variables menu in Postman" />

Next, add your credentials and set the type to **secret**. This will hide values on-screen. Once you've finished setting up your environment variables,
you can go back to basic authentication and use the variables instead of the values directly. To do this, use `{{variable_name}}` in the form field.

<Image src="/docs/images/postman-hidden-auth.png" width={1217} height={723} alt="Hidden authentication in Postman" />

## Sample request body and responses

Even with extensive documentation, it can be hard to navigate an API for the first time. To help you make requests and understand their responses, we use Postman's
[examples feature](mdc:https:/learning.postman.com/docs/sending-requests/examples/?utm_campaign=mux-collab\&utm_medium=site\&utm_source=mux) for all Mux Video and Mux Data endpoints.

You can view an endpoint's sample request body by clicking the endpoint on the left-hand API menu and then clicking **body** in the main section of the interface.

<Image src="/docs/images/postman-sample-request-body.png" width={1217} height={723} alt="Sample API request body in Postman" />

You can view an endpoint's sample request response by clicking the right-facing carat on the endpoint. A new item will appear in the collection with the icon **e.g.**.

<Image src="/docs/images/postman-sample-request-response.png" width={1217} height={523} alt="Sample API request response in Postman" />

## Stay up to date with the main collection

Similar to a forked repository on GitHub, your Postman fork will only stay up to date with the origin collection if you periodically [pull changes](mdc:https:/learning.postman.com/docs/collaborating-in-postman/version-control/#pulling-updates)
to keep your fork in sync.

You can pull changes by clicking the three dots next to the name of your fork. This will open a sub-menu. Click on **merge changes** near the bottom of the menu.

<Image src="/docs/images/postman-fork-sub-menu.png" width={517} height={123} alt="Forked Postman collection's sub-menu" />

If your fork is not in sync with the origin collection, there will be a yellow banner that states, "The destination has been modified since you last updated the fork. Weâ€™d recommend pulling changes." Click **pull changes** on the right.

You will then see a diff where source is the origin and destination is your fork.

<Image src="/docs/images/postman-pull-changes-diff.png" width={617} height={323} alt="API diff when pulling changes" />

Sometimes there will be merge conflicts. If you encounter them, you can choose whether you keep the source or destination version of a change.

Once everything looks good, click the orange button labeled **pull changes**.


# Listen for webhooks
Learn how to listen for webhooks from Mux.
Mux uses [webhooks](mdc:https:/webhooks.fyi) to let your application know when things happen asynchronously, outside of an API request cycle. For example, you may want to update something on your end when an <ApiRefLink product="video" slug="operation/get-asset">asset</ApiRefLink> transitions its status from `processing` to `ready`, or when a live stream starts or ends. When these asynchronous events happen, we'll make a POST request to the address you give us and you can do whatever you need with it on your end.

After a webhook is configured for an environment, notifications will be sent for all events for that environment.

If Mux doesn't receive a `2xx` response from your system, we will continue to try the message for the next 24 hours (with an increasing delay between attempts).

<Callout type="info">
  Mux makes an effort to deliver each message successfully once, but in certain
  situations duplicate webhook messages may be sent even if your service
  responds with a 2xx response code. Please ensure that your webhook handling
  mechanism treats duplicated event delivery appropriately.
</Callout>

# Webhooks vs. polling

Please use webhooks to track asset status rather than polling the <ApiRefLink product="video" slug="operation/get-asset">Asset API</ApiRefLink>. Webhooks are much more efficient for both you and Mux, and we rate limit GET requests to the `/assets` endpoint, which means polling the `/assets` API doesn't scale.

# Handling webhooks locally

A common gotcha for anyone new to working with webhooks is figuring out how to receive them when working in a local environment.

If your application is running on a local URL such as `https://localhost:3000` or `https://localhost:8080`, you'll need to create a [secure tunnel](mdc:https:/github.com/anderspitman/awesome-tunneling) to this port on your machine to expose it to the world.

One approach to accomplishing this is using a tool like [ngrok](mdc:https:/ngrok.com/docs/integrations/mux/webhooks) to expose your local application to the internet.

> Note: you'll need to create an ngrok account in order to take this approach â€“ a free account should be fine for most testing purposes.

As an example, if your application is running on `https://localhost:3000`, you can run `ngrok http 3000` in your terminal to get a public URL to your local application

If you're using a free ngrok account, you'll receive an auto-generated URL that will look something like this:

`https://025c-2603-6010-fd04-a497-8cc9-f31e-1e0d-1406.ngrok.io/`

You can then append your application's webhook handler path to the end of that URL and use it as the webhook endpoint within the Mux dashboard. A complete example webhook endpoint provided by ngrok might look something like this:

`https://025c-2603-6010-fd04-a497-8cc9-f31e-1e0d-1406.ngrok.io/api/webhooks/mux`

There is more detail on Mux and ngrok's integration and what is possible with it in [ngrok's documentation here](mdc:https:/ngrok.com/docs/integrations/mux/webhooks).

# Configuring endpoints

Webhook endpoints are configured in the Mux dashboard under "Settings."

<Image src="/docs/images/webhooks.png" width={454} height={734} />

Enter a URL from your application that Mux will call for event notifications.

<Image src="/docs/images/new-webhook.png" width={1192} height={898} />

# Receiving events

Mux will submit a POST request to the configured URL, which your application can treat the same as any other route. Your event handler can do things like update the state of the specified asset in your database, or trigger other work.

Note that a single request attempt will timeout after 5 seconds, after which the attempt is considered failed and will be reattempted. If you expect this will be a problem in your workflow, consider doing the work in an asynchronous task so you can respond to the event immediately.

For more details on the Webhook event object definition, see [the example response](mdc:#example-response).

# Example response

```json
{
  "type": "video.asset.ready",
  "object": {
    "type": "asset",
    "id": "0201p02fGKPE7MrbC269XRD7LpcHhrmbu0002"
  },
  "id": "3a56ac3d-33da-4366-855b-f592d898409d",
  "environment": {
    "name": "Demo pages",
    "id": "j0863n"
  },
  "data": {
    "tracks": [
      {
        "type": "video",
        "max_width": 1280,
        "max_height": 544,
        "max_frame_rate": 23.976,
        "id": "0201p02fGKPE7MrbC269XRD7LpcHhrmbu0002",
        "duration": 153.361542
      },
      {
        "type": "audio",
        "max_channels": 2,
        "max_channel_layout": "stereo",
        "id": "FzB95vBizv02bYNqO5QVzNWRrVo5SnQju",
        "duration": 153.361497
      }
    ],
    "status": "ready",
    "max_stored_resolution": "SD",
    "max_stored_frame_rate": 23.976,
    "id": "0201p02fGKPE7MrbC269XRD7LpcHhrmbu0002",
    "duration": 153.361542,
    "created_at": "2018-02-15T01:04:45.000Z",
    "aspect_ratio": "40:17"
  },
  "created_at": "2018-02-15T01:04:45.000Z",
  "accessor_source": null,
  "accessor": null,
  "request_id": null
}
```

# Types of Events

## Asset Events

| Event | Description |
|-------|-------------|
| `video.asset.created` | Asset has been created |
| `video.asset.ready` | Asset is ready for playback. You can now use the asset's `playback_id` to successfully start streaming this asset. |
| `video.asset.errored` | Asset has encountered an error. Use this to notify your server about assets with errors. Asset errors can happen for a number of reasons, most commonly an input URL that Mux is unable to download or a file that is not a valid video file. |
| `video.asset.updated` | Asset has been updated. Use this to make sure your server is notified about changes to assets. |
| `video.asset.deleted` | Asset has been deleted. Use this so that your server knows when an asset has been deleted, at which point it will no longer be playable. |
| `video.asset.live_stream_completed` | The live stream for this asset has completed. Every time a live stream starts and ends a new asset gets created and this event fires. |
| `video.asset.static_renditions.ready` | Static renditions for this asset are ready. Static renditions are streamable mp4 files that are most commonly used for allowing users to download files for offline viewing. |
| `video.asset.static_renditions.preparing` | Static renditions for this asset are being prepared. After requesting static renditions you will get this webhook when they are being prepared. |
| `video.asset.static_renditions.deleted` | Static renditions for this asset have been deleted. The static renditions (mp4 files) for this asset will no longer be available. |
| `video.asset.static_renditions.errored` | Preparing static renditions for this asset has encountered an error. This indicates that there was some error when creating static renditions (mp4s) of your asset. This should be rare and if you see it unexpectedly please open a support ticket. |
| `video.asset.master.ready` | Master access for this asset is ready. Master access is used when downloading an asset for purposes of editing or post-production work. The master access file is not intended to be streamed or downloaded by end-users. |
| `video.asset.master.preparing` | Master access for this asset is being prepared. After requesting master access you will get this webhook while it is being prepared. |
| `video.asset.master.deleted` | Master access for this asset has been deleted. Master access for this asset has been removed. You will no longer be able to download the master file. If you want it again you should re-request it. |
| `video.asset.master.errored` | Master access for this asset has encountered an error. This indicates that there was some error when creating master access for this asset. This should be rare and if you see it unexpectedly please open a support ticket. |
| `video.asset.track.created` | A new track for this asset has been created, for example a subtitle text track. |
| `video.asset.track.ready` | A track for this asset is ready. In the example of a subtitle text track the text track will now be delivered with your HLS stream. |
| `video.asset.track.errored` | A track for this asset has encountered an error. There was some error preparing this track. Most commonly this could be a text track file that Mux was unable to download for processing. |
| `video.asset.track.deleted` | A track for this asset has been deleted. |
| `video.asset.warning` | This event fires when Mux has encountered a non-fatal issue with the recorded asset of the live stream. At this time, the event is only fired when Mux is unable to download a slate image from the URL set as `reconnect_slate_url` parameter value. More details on this event is available [here](mdc:docs/guides/handle-live-stream-disconnects#reconnect-window-and-slates). |

## Upload Events

| Event | Description |
|-------|-------------|
| `video.upload.asset_created` | An asset has been created from this upload. This is useful to know what a user of your application has finished uploading a file using the URL created by a [Direct Upload](mdc:docs/guides/upload-files-directly). |
| `video.upload.cancelled` | Upload has been canceled. This event fires after hitting the <ApiRefLink product="video" slug="operation/cancel-direct-upload">cancel direct upload</ApiRefLink> API. |
| `video.upload.created` | Upload has been created. This event fires after <ApiRefLink product="video" slug="operation/create-direct-upload">creating a direct upload</ApiRefLink>. |
| `video.upload.errored` | Upload has encountered an error. This event fires when the asset created by the direct upload fails. Most commonly this happens when an end-user uploads a non-video file. |

## Live Stream Events

| Event | Description |
|-------|-------------|
| `video.live_stream.created` | A new live stream has been created. Broadcasters with a `stream_key` can start sending encoder feed to this live stream. |
| `video.live_stream.connected` | An encoder has successfully connected to this live stream. |
| `video.live_stream.recording` | Recording on this live stream has started. Mux has successfully processed the first frames from the encoder. If you show a *red dot* icon in your UI, this would be a good time to show it. |
| `video.live_stream.active` | This live stream is now "active". The live streams `playback_id` OR the `playback_id` associated with this live stream's asset can be used right now to created HLS URLs (`https://stream.mux.com/{PLAYBACK_ID}.m3u8` and start streaming in your player. Note that before the live stream is `"active"`, trying to stream the HLS URL will result in HTTP `412` errors. |
| `video.live_stream.disconnected` | An encoder has disconnected from this live stream. Note that while disconnected the live stream is still `status: "active"`. |
| `video.live_stream.idle` | The `reconnect_window` for this live stream has elapsed. The live stream `status` will now transition to `"idle"`. |
| `video.live_stream.updated` | This live stream has been updated. For example, after <ApiRefLink product="video" slug="operation/reset-stream-key">resetting the live stream's stream key</ApiRefLink>. |
| `video.live_stream.enabled` | This live stream has been enabled. This event fires after <ApiRefLink product="video" slug="operation/enable-live-stream">enable live stream</ApiRefLink> API. |
| `video.live_stream.disabled` | This live stream has been disabled. This event fires after <ApiRefLink product="video" slug="operation/enable-live-stream">disable live stream</ApiRefLink> API. Disabled live streams will no longer accept new RTMP connections. |
| `video.live_stream.deleted` | This live stream has been deleted. This event fires after <ApiRefLink product="video" slug="operation/enable-live-stream">delete live stream API</ApiRefLink> API. |
| `video.live_stream.warning` | This live stream event fires when Mux has encountered a non-fatal issue. There is no disruption to the live stream ingest and playback. At this time, the event is only fired when Mux is unable to download an image from the URL set as `reconnect_slate_url` parameter value. More details on this event is available [here](mdc:docs/guides/handle-live-stream-disconnects#reconnect-window-and-slates). |

## Simulcast Target Events

These simulcast target events are useful when creating a UI that shows your users the status of their configured 3rd party endpoints. These events are handy when you want to build a UI that shows the state of each simulcast target and keep track of the state changes as they happen.

| Event | Description |
|-------|-------------|
| `video.live_stream.simulcast_target.created` | A new simulcast target has been created for this live stream. |
| `video.live_stream.simulcast_target.idle` | When the parent live stream is `"disconnected"`, all simulcast targets will have be `"idle"`. |
| `video.live_stream.simulcast_target.starting` | When the parent live stream fires `"connected"` then the simulcast targets transition to `"starting"`. |
| `video.live_stream.simulcast_target.broadcasting` | This fires when Mux has successfully connected to the simulcast target and has begun pushing content to that third party. |
| `video.live_stream.simulcast_target.errored` | This fires when Mux has encountered an error either while attempting to connect to the third party streaming service or while broadcasting. Mux will try to re-establish the connection and if it does successfully the simulcast target will transition back to `"broadcasting"`. |
| `video.live_stream.simulcast_target.updated` | This simulcast target has been updated. |
| `video.live_stream.simulcast_target.deleted` | This simulcast target has been deleted. |

## Web Input Events <BetaTag />

<Callout type="info">
  Web Inputs are currently in beta, please [contact us](mdc:https:/www.mux.com/support) if you're interested in using Web Inputs.
</Callout>

These events describe the states of Web Inputs during their lifecycle.

| Event | Description |
|-------|-------------|
| `video.web_input.created` | A new Web Input has been created. |
| `video.web_input.idle` | The Web Input has transitioned into the `idle` status, usually through the use of the <ApiRefLink product="video" slug="operation/shutdown-web-input">shutdown Web Input API</ApiRefLink>. |
| `video.web_input.launching` | The Web Input is launching. This includes creating the underlying browser instance that powers Web Inputs. It is normal for Web Inputs to be in the `launching` state for several seconds. |
| `video.web_input.streaming` | The Web Input has launched, and started streaming to the specified Live Stream. You should wait for the `status` of the associated Live Stream to enter `active` before attempting to use the Live Stream. |
| `video.web_input.updated` | This Web Input has been updated. Currently this is triggered by using the <ApiRefLink product="video" slug="operation/update-web-input-url">update Web Input URL</ApiRefLink> or <ApiRefLink product="video" slug="operation/reload-web-input">reload Web Input</ApiRefLink> APIs. |
| `video.web_input.deleted` | This Web Input has been deleted. |


# Verify webhook signatures
You have the option to verify webhook requests that Mux sends to your endpoints. Mux will include a signature in the request's header. You can use this signature in your code to make sure the request was sent by Mux and not a third party.
## Obtain your signing secret

Before you get started, you will need your signing secret for your webhook. You can find that where you configure webhooks on the [webhooks settings page](mdc:https:/dashboard.mux.com/settings/webhooks). Please note that the signing secret is different for each webhook endpoint that we notify.

<Image src="/docs/images/webhook-security.png" width={1181} height={479} />

Webhooks contain a header called `mux-signature` with the timestamp and a signature. The timestamp is prefixed by `t=` and the signature is prefixed by a scheme. Schemes start with `v`, followed by an integer. Currently, the only valid signature scheme is `v1`. Mux generates signatures using [HMAC](mdc:https:/en.wikipedia.org/wiki/HMAC) with [SHA-256](mdc:https:/en.wikipedia.org/wiki/SHA-2).

```text
Mux-Signature: t=1565220904,v1=20c75c1180c701ee8a796e81507cfd5c932fc17cf63a4a55566fd38da3a2d3d2`
```

## How to verify webhook signatures

### Step 1: Extract the timestamp and signature

Split the header at the `,` character and get the values for `t` (timestamp) and `v1` (the signature)

### Step 2: Prepare the `signed_payload` string

You will need:

* the timestamp from Step 1 as a string (for example: "1565220904")
* the dot character `.`
* the raw request body (this will be JSON in a string format)

### Step 3: Determine the expected signature

Use the 3 components from Step 2 to compute an HMAC with the SHA256 hash function. Depending on the language that you are using this will look something like the following:

```js
secret = 'my secret' // your signing secret
payload = timestamp + "." + request_body
expected_signature = createHmacSha256(payload, secret)
```

### Step 4: Compare signature

Compare the signature in the header to the expected signature. If the signature matches, compute the difference between the current timestamp and the received timestamp, then check to make sure that the timestamp is within our tolerance. By default, our SDKs allow a tolerance of 5 minutes.

## Examples

Our official SDKs for [Node](mdc:https:/github.com/muxinc/mux-node-sdk) and [Elixir](mdc:https:/github.com/muxinc/mux-elixir) contain helper methods for verifying Mux webhooks. If you're using one of these languages it's best to use our available helper methods. Note that the helper methods use the raw request body instead of a payload including the timestamp.

```elixir

# check the mux-elixr docs for details and a full example using Phoenix
# https://github.com/muxinc/mux-elixir#verifying-webhook-signatures-in-phoenix
Mux.Webhooks.verify_header(raw_body, signature_header, secret)

```

```go

func generateHmacSignature(webhookSecret, payload string) string {
    h := hmac.New(sha256.New, []byte(webhookSecret))
    h.Write([]byte(payload))
    return hex.EncodeToString(h.Sum(nil))
}

func IsValidMuxSignature(req *http.Request, body []byte) error {
    muxSignature := req.Header.Get("Mux-Signature")

    if muxSignature == "" {
        return errors.New("no Mux-Signature in request header")
    }

    muxSignatureArr := strings.Split(muxSignature, ",")

    if len(muxSignatureArr) != 2 {
        return errors.New(fmt.Sprintf("Mux-Signature in request header should be 2 values long: %s", muxSignatureArr))
    }

    timestampArr := strings.Split(muxSignatureArr[0], "=")
    v1SignatureArr := strings.Split(muxSignatureArr[1], "=")

    if len(timestampArr) != 2 || len(v1SignatureArr) != 2 {
        return errors.New(fmt.Sprintf("missing timestamp: %s or missing v1Signature: %s", timestampArr, v1SignatureArr))
    }

    timestamp := timestampArr[1]
    v1Signature := v1SignatureArr[1]

    webhookSecret := "" //insert secret here or load from config file.
    payload := fmt.Sprintf("%s.%s", timestamp, string(body))
    sha := generateHmacSignature(webhookSecret, payload)

    if sha != v1Signature {
        return errors.New("not a valid mux webhook signature")
    }

    fmt.Println("timestamp sha:", sha)
    fmt.Println("v1Signature:", v1Signature)
    return nil
}

```

```laravel

/**
 * Verify the signature (laravel)
 *
 * @param Request $request
 * @return boolean
 */
protected function verifySignature(Request $request)
{
    // Get the signature from the request header
    $muxSig = $request->header('Mux-Signature');

    if(empty($muxSig)) {
        return false;
    }

    // Split the signature based on ','.
    // Format is 't=[timestamp],v1=[hash]'
    $muxSigArray = explode(',', $muxSig);

    if(empty($muxSigArray) || empty($muxSigArray[0]) || empty($muxSigArray[1])) {
        return false;
    }

    // Strip the first occurence of 't=' and 'v1=' from both strings
    $muxTimestamp = Str::replaceFirst('t=', '', $muxSigArray[0]);
    $muxHash = Str::replaceFirst('v1=', '', $muxSigArray[1]);

    // Create a payload of the timestamp from the Mux signature and the request body with a '.' in-between
    $payload = $muxTimestamp . "." . $request->getContent();

    // Build a HMAC hash using SHA256 algo, using our webhook secret
    $ourSignature = hash_hmac('sha256', $payload, config('mux.webhook_secret'));

    // `hash_equals` performs a timing-safe crypto comparison
    return hash_equals($ourSignature, $muxHash);
}

```

```node

import Mux from '@mux/mux-node';

// check the mux-node-sdk docs for details
// https://github.com/muxinc/mux-node-sdk/blob/master/api.md#webhooks
const mux = new Mux();
mux.webhooks.verifySignature(body, headers, secret);

```
