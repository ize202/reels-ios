//
//  AuthGeneral.swift
//  SupabaseKit (Generated by SwiftyLaunch 2.0)
//  https://docs.swiftylaun.ch/module/authkit
//

import AnalyticsKit
import Foundation
import SharedKit
import Supabase

//MARK: - Auth Stuff (General)
extension DB {

	// Supabase calls this function when user state changes
	@MainActor
	internal func registerAuthStateListener(
		additionalHandler: @escaping (AuthChangeEvent, Session?) -> Void
	) async {
		// Clean up existing handler if any
		authStateHandler?.remove()
		
		// Register new handler
		authStateHandler = await _db.auth.onAuthStateChange { [weak self] event, session in
			Analytics.capture(
				.info,
				id: "auth_state_change",
				longDescription: "New Auth State Change: \(event)",
				source: .auth
			)
			
			Task { @MainActor in
				guard let self = self else { return }
				
				switch event {
				case .initialSession, .signedIn:
					self.currentUser = session?.user
					self.authState = .signedIn
				case .signedOut:
					self.currentUser = nil
					self.authState = .signedOut
				case .passwordRecovery, .tokenRefreshed, .userUpdated, .userDeleted, .mfaChallengeVerified:
					break
				}
				
				additionalHandler(event, session)
			}
		}
		
		// Try to sign in anonymously if needed
		do {
			try await signInAnonymouslyIfNeeded()
		} catch {
			if let authError = error as? AuthKitError {
				authError.showAsInAppNotification()
			}
		}
	}

	public func signOut() async throws {
		Analytics.capture(.info, id: "sign_out_called", source: .auth)
		do {
			try await _db.auth.signOut()
		} catch {
			Analytics.capture(
				.error, id: "sign_out", longDescription: "Error signing out: \(error.localizedDescription)",
				source: .auth)
			throw AuthKitError.defaultSignOutError
		}
	}

	/// Will extract all the relevant data out of User and return it as a dictionary that we will use for analytics
	static public func convertAuthUserToAnalyticsUserProperties(_ user: User) -> [String: Any] {
		var userProperties: [String: Any] = [:]
		userProperties["email"] = user.email ?? "Unknown"
		userProperties["signin_method"] = "apple"
		return userProperties
	}

	/// Deletes the current user's account and all associated data
	@MainActor
	public func deleteAccount() async throws {
		Analytics.capture(.info, id: "delete_account_called", source: .auth)
		
		guard let user = currentUser else {
			Analytics.capture(
				.error,
				id: "delete_account",
				longDescription: "No user signed in",
				source: .auth
			)
			throw AuthKitError.noUserSignedIn
		}
		
		do {
			// Call the Edge Function to delete the user
			// The invoke function returns Void on success, throws on error
			try await _db.functions.invoke(
				"delete-account",
				options: FunctionInvokeOptions(body: ["user_id": user.id.uuidString])
			)
			
			// If invoke didn't throw, assume success
			
			// Sign out the user after successful deletion
			try await signOut()
			
			Analytics.capture(
				.success,
				id: "delete_account",
				longDescription: "Successfully deleted user: \(user.id)",
				source: .auth
			)
		} catch {
			Analytics.capture(
				.error,
				id: "delete_account",
				longDescription: "Error deleting account: \(error)",
				source: .auth
			)
			throw AuthKitError.catchAllError
		}
	}
}

//MARK: - Helper functions for Auth-based actions

/// If a function is called via executeIfSignedIn, what to do if the user is not signed in
public enum NotSignedInConsequence {
	/// Just show a notification, telling the user they are not signed in
	case showInAppNotification

	/// Or show the sign in screen
	case showSignInScreen
}

extension DB {

	/// Perform an action only if a user is signed in. Otherwise show an in-app notification or show the sign in sheet
	public func executeIfSignedIn(
		otherwise consequence: NotSignedInConsequence = .showInAppNotification,
		_ closure: () -> Void
	) {
		guard authState == .signedIn else {
			_consequenceExecutionForNotSignedIn(consequence)
			return
		}
		closure()
	}

	/// Async version.
	/// Perform an action only if a user is signed in. Otherwise show an in-app notification or show the sign in sheet
	public func executeIfSignedIn(
		otherwise consequence: NotSignedInConsequence = .showInAppNotification,
		_ closure: () async -> Void
	) async {
		guard authState == .signedIn else {
			_consequenceExecutionForNotSignedIn(consequence)
			return
		}
		await closure()
	}

	/// Perform an action only if a user is signed in as a user with userID. Otherwise show an in-app notification or show the sign in sheet
	public func executeIfSignedIn(
		withUserID userID: UUID?,
		otherwise consequence: NotSignedInConsequence = .showInAppNotification,
		_ closure: () -> Void
	) {
		guard authState == .signedIn else {
			_consequenceExecutionForNotSignedIn(consequence)
			return
		}
		guard userID != nil && userID == currentUser?.id else {
			showInAppNotification(
				.error,
				content: .init(
					title: "Access Forbidden",
					message: "You can't perform this action."),
				size: .compact
			)
			return
		}
		closure()
	}

	/// Async version.
	/// Perform an action only if a user is signed in as a user with userID. Otherwise show an in-app notification or show the sign in sheet
	public func executeIfSignedIn(
		withUserID userID: UUID?,
		otherwise consequence: NotSignedInConsequence = .showInAppNotification,
		_ closure: () async -> Void
	) async {
		guard authState == .signedIn else {
			_consequenceExecutionForNotSignedIn(consequence)
			return
		}
		guard userID != nil && userID == currentUser?.id else {
			showInAppNotification(
				.error,
				content: .init(
					title: "Access Forbidden",
					message: "You can't perform this action."),
				size: .compact
			)
			return
		}
		await closure()
	}

	/// Internal function for the above functionality
	private func _consequenceExecutionForNotSignedIn(_ consequence: NotSignedInConsequence) {
		if consequence == .showInAppNotification {
			showInAppNotification(
				.error, content: .init(title: "Sign In Required", message: "Can't perform this action"),
				size: .compact)
		} else {
			showSignInSheet()
		}
	}
}
