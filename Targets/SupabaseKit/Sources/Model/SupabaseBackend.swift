//
//  SupabaseBackend.swift
//  SupabaseKit (Generated by SwiftyLaunch 2.0)
//  https://docs.swiftylaun.ch/module/authkit
//  https://docs.swiftylaun.ch/module/databasekit
//

import AnalyticsKit
import AuthenticationServices
import Foundation
import SharedKit
import Supabase
import SwiftUI

/// Enum representing authentication states.
public enum AuthState {
	case signedOut
	case signedIn
}

/// Represents data structure for a post.
struct PostData: Codable, Identifiable, Equatable {
	let id: Int
	let title: String
	let content: String
	let creationDate: Date
	let postUserID: UUID  // post author id
}

/// Represents a drama series in the app
public struct Series: Codable, Identifiable, Equatable {
	public let id: UUID
	public let title: String
	public let description: String?
	public let genre: String
	public let coverUrl: String?
	public let isPublished: Bool
	public let createdAt: Date
	
	private enum CodingKeys: String, CodingKey {
		case id, title, description, genre
		case coverUrl = "cover_url"
		case isPublished = "is_published"
		case createdAt = "created_at"
	}
}

/// Represents an episode in a series
public struct Episode: Codable, Identifiable, Equatable {
	public let id: UUID
	public let seriesId: UUID
	public let muxAssetId: String
	public let playbackUrl: String
	public let episodeNumber: Int
	public let unlockType: UnlockType
	public let coinCost: Int?
	public let createdAt: Date
	
	private enum CodingKeys: String, CodingKey {
		case id
		case seriesId = "series_id"
		case muxAssetId = "mux_asset_id"
		case playbackUrl = "playback_url"
		case episodeNumber = "episode_number"
		case unlockType = "unlock_type"
		case coinCost = "coin_cost"
		case createdAt = "created_at"
	}
	
	public enum UnlockType: String, Codable {
		case free
		case coin
		case ad
		case vip
	}
}

@MainActor
public class DB: ObservableObject {

	/// Variable reference to access Supabase.
	///
	/// Don't access it directly, to fetch data, but rather do so via
	/// dedicated functions such as the `fetchPosts()` example function below.
	internal let _db: SupabaseClient

	/// See DatabaseExampleView.swift
	@Published var posts: [PostData] = []

	/// SupabaseAuth user state, nil if not logged in
	@Published public var currentUser: User? = nil

	/// SupabaseAuth State (use this to check auth state, updates with currentUser)
	@Published public var authState: AuthState = .signedOut

	/// For Supabase to keep track of the Auth State (see AuthGeneral.swift)
	internal var authStateHandler: AuthStateChangeListenerRegistration?

	/// For Sign in With Apple (Specifically, for account deletion. Is set when the user signs in with Apple)
	internal var appleIDCredential: ASAuthorizationAppleIDCredential?

	/// For Sign in With Apple (see SignInWithApple.siwft)
	internal var currentNonce: String?

	///- Parameter onAuthStateChange: Additional closure to pass to the AuthState Listener.
	/// We use this to set all the different providers to use the same, supabase-issued user ID to identify the user.
	public init(
		onAuthStateChange: @escaping (AuthChangeEvent, Session?) -> Void = { _, _ in }
	) {

		#if DEBUG
		let urlKey = "SUPABASE_DEV_URL"
		let apiKeyKey = "SUPABASE_DEV_KEY"
		print("[DB] Using development database")
		#else
		let urlKey = "SUPABASE_URL"
		let apiKeyKey = "SUPABASE_KEY"
		print("[DB] Using production database")
		#endif
		
		let supabaseURLString = try? getPlistEntry(urlKey, in: "Supabase-Info")
		let apiKey = try? getPlistEntry(apiKeyKey, in: "Supabase-Info")

		guard let apiKey, let supabaseURLString, let supabaseURL = URL(string: supabaseURLString) else {
			fatalError("ERROR Couldn't get SupabaseURL and API Keys in Supabase-Info.plist!")
		}

		_db = SupabaseClient(
			supabaseURL: supabaseURL,
			supabaseKey: apiKey
		)

		Task {
			await registerAuthStateListener(additionalHandler: onAuthStateChange)
		}
	}
}

//MARK: - DatabaseExampleView
extension DB {

	/// Fetches posts from the database asynchronously and sets them in the `posts` property.
	@MainActor
	public func fetchPosts() async {
		Analytics.capture(.info, id: "fetch_posts_called", source: .db)
		var newPostsData: [PostData] = []

		do {
			newPostsData = try await _db.from("posts").select().execute().value

			Analytics.capture(
				.success, id: "fetch_posts", longDescription: "Fetched \(newPostsData.count) posts from the db.",
				source: .db)

		} catch {
			Analytics.capture(
				.error, id: "fetch_posts", longDescription: "Error fetching posts: \(error)", source: .db)
			return
		}
		newPostsData.sort(by: { $0.creationDate > $1.creationDate })
		posts = newPostsData
	}

	/// Adds a post anonymously to the database.
	public func addPost(title: String, content: String) async -> Bool {
		Analytics.capture(.info, id: "add_post_called", source: .db)
		do {

			// If we just insert using the normal PostData, we will have to provide
			// it with an ID and a creationDate. If we don't pass them, the DB will automatically
			// assign the newly created post these values.
			// (If you have set up your DB to automatically set default values)
			struct PostDataWithoutIdAndDate: Encodable {
				let title: String
				let content: String
			}

			// Add a new post to the DB with provided values
			// and return the result.
			let createdPost: PostData =
				try await _db
				.from("posts")
				.insert(PostDataWithoutIdAndDate(title: title, content: content))
				.select()
				.single()
				.execute()
				.value

			Analytics.capture(
				.success, id: "add_post", longDescription: "User created post with ID: \(createdPost.id)",
				source: .db)
			return true
		} catch {
			Analytics.capture(
				.error, id: "add_post", longDescription: "Error during post creation: \(error)", source: .db)
			return false
		}
	}

	public func deletePost(id: Int) async {
		Analytics.capture(.info, id: "delete_post_called", longDescription: "PostID: \(id)", source: .db)
		do {
			try await _db.from("posts").delete().eq("id", value: id).execute()
			Analytics.capture(.success, id: "delete_post", longDescription: "PostID: \(id)", source: .db)
		} catch {
			Analytics.capture(
				.error, id: "delete_post",
				longDescription: "Error deleting post with ID: \(id): \(error.localizedDescription)", source: .db)
		}
	}
}

//MARK: - Series & Episodes
extension DB {
	/// Fetches all published series from the database
	@MainActor
	public func fetchAllSeries() async throws -> [Series] {
		Analytics.capture(.info, id: "fetch_all_series_called", source: .db)
		do {
			let series: [Series] = try await _db
				.from("series")
				.select()
				.eq("is_published", value: true)
				.order("created_at", ascending: false)
				.execute()
				.value
			
			Analytics.capture(
				.success,
				id: "fetch_all_series",
				longDescription: "Fetched \(series.count) series from the db.",
				source: .db
			)
			
			return series
		} catch {
			Analytics.capture(
				.error,
				id: "fetch_all_series",
				longDescription: "Error fetching series: \(error)",
				source: .db
			)
			throw error
		}
	}
	
	/// Fetches episodes for a specific series
	@MainActor
	public func fetchEpisodes(forSeriesId seriesId: UUID) async throws -> [Episode] {
		Analytics.capture(.info, id: "fetch_episodes_called", source: .db)
		do {
			let episodes: [Episode] = try await _db
				.from("episodes")
				.select()
				.eq("series_id", value: seriesId)
				.order("episode_number")
				.execute()
				.value
			
			Analytics.capture(
				.success,
				id: "fetch_episodes",
				longDescription: "Fetched \(episodes.count) episodes for series \(seriesId)",
				source: .db
			)
			
			return episodes
		} catch {
			Analytics.capture(
				.error,
				id: "fetch_episodes",
				longDescription: "Error fetching episodes: \(error)",
				source: .db
			)
			throw error
		}
	}
}

//MARK: - Auth
extension DB {
	/// Static flag to prevent multiple simultaneous anonymous sign-ins
	private static var isSigningInAnonymously = false
	
	/// Signs in anonymously if no session exists
	@MainActor
	public func signInAnonymouslyIfNeeded() async throws {
		Analytics.capture(.info, id: "check_anonymous_signin", source: .db)
		
		// Check if we already have a session
		if let session = try? await _db.auth.session {
			Analytics.capture(
				.info,
				id: "existing_session_found",
				longDescription: "User ID: \(session.user.id)",
				source: .db
			)
			self.currentUser = session.user
			self.authState = .signedIn
			return
		}
		
		// No session exists, sign in anonymously
		Analytics.capture(.info, id: "attempting_anonymous_signin", source: .db)
		
		do {
			let session = try await _db.auth.signInAnonymously()
			
			Analytics.capture(
				.success,
				id: "anonymous_signin",
				longDescription: "Created anonymous user with ID: \(session.user.id)",
				source: .db
			)
			
			self.currentUser = session.user
			self.authState = .signedIn
		} catch {
			Analytics.capture(
				.error,
				id: "anonymous_signin",
				longDescription: "Error during anonymous sign in: \(error)",
				source: .db
			)
			self.authState = .signedOut
			throw AuthKitError.anonymousSignInError
		}
	}
}
