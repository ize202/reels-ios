//
//  SupabaseBackend.swift
//  SupabaseKit (Generated by SwiftyLaunch 2.0)
//  https://docs.swiftylaun.ch/module/authkit
//  https://docs.swiftylaun.ch/module/databasekit
//

import AnalyticsKit
import AuthenticationServices
import Foundation
import SharedKit
import Supabase
import SwiftUI

// Add a Notification Name for library updates
public extension Notification.Name {
	static let didUpdateUserLibrary = Notification.Name("didUpdateUserLibrary")
}

/// Enum representing authentication states.
public enum AuthState {
	case signedOut
	case signedIn
}

/// Represents data structure for a post.
struct PostData: Codable, Identifiable, Equatable {
	let id: Int
	let title: String
	let content: String
	let creationDate: Date
	let postUserID: UUID  // post author id
}

/// Represents a drama series in the app
public struct Series: Codable, Identifiable, Equatable {
	public let id: UUID
	public let title: String
	public let description: String?
	public let genre: String
	public let coverUrl: String?
	public let isPublished: Bool
	public let createdAt: Date
	
	private enum CodingKeys: String, CodingKey {
		case id, title, description, genre
		case coverUrl = "cover_url"
		case isPublished = "is_published"
		case createdAt = "created_at"
	}
}

/// Represents an episode in a series
public struct Episode: Codable, Identifiable, Equatable {
	public let id: UUID
	public let seriesId: UUID
	public let muxAssetId: String
	public let playbackUrl: String
	public let episodeNumber: Int
	public let unlockType: UnlockType
	public let coinCost: Int?
	public let createdAt: Date
	
	private enum CodingKeys: String, CodingKey {
		case id
		case seriesId = "series_id"
		case muxAssetId = "mux_asset_id"
		case playbackUrl = "playback_url"
		case episodeNumber = "episode_number"
		case unlockType = "unlock_type"
		case coinCost = "coin_cost"
		case createdAt = "created_at"
	}
	
	public enum UnlockType: String, Codable {
		case free
		case coin
		case ad
		case vip
	}
}

/// Represents an entry in the user_library table
struct UserLibraryEntry: Codable {
	let userId: UUID
	let seriesId: UUID
	let lastEpisodeId: UUID
	let isSaved: Bool

	enum CodingKeys: String, CodingKey {
		case userId = "user_id"
		case seriesId = "series_id"
		case lastEpisodeId = "last_episode_id"
		case isSaved = "is_saved"
	}
}

/// Represents the combined details fetched for a user's library entry
public struct UserLibraryDetail: Codable, Identifiable, Equatable {
	public var id: UUID { seriesId } // Use seriesId as identifiable ID
	public let userId: UUID
	public let seriesId: UUID
	public let lastEpisodeId: UUID?
	public let isSaved: Bool
	public let title: String
	public let coverUrl: String?
	public let lastWatchedEpisodeNumber: Int?
	public let totalEpisodes: Int

	// Map database column names to Swift properties
	private enum CodingKeys: String, CodingKey {
		case userId = "user_id"
		case seriesId = "series_id"
		case lastEpisodeId = "last_episode_id"
		case isSaved = "is_saved"
		case title
		case coverUrl = "cover_url"
		case lastWatchedEpisodeNumber = "last_watched_episode_number"
		case totalEpisodes = "total_episodes"
	}

	// Custom decoder to handle potential Int64 from COUNT(*)
	public init(from decoder: Decoder) throws {
		let container = try decoder.container(keyedBy: CodingKeys.self)
		userId = try container.decode(UUID.self, forKey: .userId)
		seriesId = try container.decode(UUID.self, forKey: .seriesId)
		lastEpisodeId = try container.decodeIfPresent(UUID.self, forKey: .lastEpisodeId)
		isSaved = try container.decode(Bool.self, forKey: .isSaved)
		title = try container.decode(String.self, forKey: .title)
		coverUrl = try container.decodeIfPresent(String.self, forKey: .coverUrl)
		lastWatchedEpisodeNumber = try container.decodeIfPresent(Int.self, forKey: .lastWatchedEpisodeNumber)

		// Decode totalEpisodes safely, trying Int first, then Int64
		if let intValue = try? container.decode(Int.self, forKey: .totalEpisodes) {
			totalEpisodes = intValue
		} else {
			let int64Value = try container.decode(Int64.self, forKey: .totalEpisodes)
			totalEpisodes = Int(int64Value) // Convert Int64 to Int
		}
	}
}

@MainActor
public class DB: ObservableObject {
	/// Shared instance for the entire app
    public static var shared = DB()
	
	/// Define a custom error for validation within this scope
	public struct ValidationError: LocalizedError {
		public let message: String
		public var errorDescription: String? { message }
	}

	/// Variable reference to access Supabase.
	///
	/// Don't access it directly, to fetch data, but rather do so via
	/// dedicated functions such as the `fetchPosts()` example function below.
	internal let _db: SupabaseClient

	/// See DatabaseExampleView.swift
	@Published var posts: [PostData] = []

	/// SupabaseAuth user state, nil if not logged in
	@Published public var currentUser: User? = nil

	/// SupabaseAuth State (use this to check auth state, updates with currentUser)
	@Published public var authState: AuthState = .signedOut

	/// For Supabase to keep track of the Auth State (see AuthGeneral.swift)
	internal var authStateHandler: AuthStateChangeListenerRegistration?

	/// For Sign in With Apple (Specifically, for account deletion. Is set when the user signs in with Apple)
	internal var appleIDCredential: ASAuthorizationAppleIDCredential?

	/// For Sign in With Apple (see SignInWithApple.siwft)
	internal var currentNonce: String?

	///- Parameter onAuthStateChange: Additional closure to pass to the AuthState Listener.
	/// We use this to set all the different providers to use the same, supabase-issued user ID to identify the user.
	private init(
		onAuthStateChange: @escaping (AuthChangeEvent, Session?) -> Void = { _, _ in }
	) {
		#if DEBUG
		let urlKey = "SUPABASE_DEV_URL"
		let apiKeyKey = "SUPABASE_DEV_KEY"
		print("[DB] Using development database")
		#else
		let urlKey = "SUPABASE_URL"
		let apiKeyKey = "SUPABASE_KEY"
		print("[DB] Using production database")
		#endif
		
		let supabaseURLString = try? getPlistEntry(urlKey, in: "Supabase-Info")
		let apiKey = try? getPlistEntry(apiKeyKey, in: "Supabase-Info")

		guard let apiKey, let supabaseURLString, let supabaseURL = URL(string: supabaseURLString) else {
			fatalError("ERROR Couldn't get SupabaseURL and API Keys in Supabase-Info.plist!")
		}

		_db = SupabaseClient(
			supabaseURL: supabaseURL,
			supabaseKey: apiKey
		)

		Task {
			await registerAuthStateListener(additionalHandler: onAuthStateChange)
		}
	}
	
	/// Configure the shared instance with auth state change handler
	public static func configure(onAuthStateChange: @escaping (AuthChangeEvent, Session?) -> Void) {
		// Create a new shared instance with the auth state change handler
		shared = DB(onAuthStateChange: onAuthStateChange)
	}
	
	#if DEBUG
	/// Preview helper - only available in DEBUG
	public static func preview() -> DB {
		DB()
	}
	#endif
}

//MARK: - Series & Episodes
extension DB {
	/// Fetches all published series from the database
	@MainActor
	public func fetchAllSeries() async throws -> [Series] {
		Analytics.capture(.info, id: "fetch_all_series_called", source: .db)
		do {
			let series: [Series] = try await _db
				.from("series")
				.select()
				.eq("is_published", value: true)
				.order("created_at", ascending: false)
				.execute()
				.value
			
			Analytics.capture(
				.success,
				id: "fetch_all_series",
				longDescription: "Fetched \(series.count) series from the db.",
				source: .db
			)
			
			return series
		} catch {
			Analytics.capture(
				.error,
				id: "fetch_all_series",
				longDescription: "Error fetching series: \(error)",
				source: .db
			)
			throw error
		}
	}
	
	/// Fetches episodes for a specific series
	@MainActor
	public func fetchEpisodes(forSeriesId seriesId: UUID) async throws -> [Episode] {
		Analytics.capture(.info, id: "fetch_episodes_called", source: .db)
		do {
			let episodes: [Episode] = try await _db
				.from("episodes")
				.select()
				.eq("series_id", value: seriesId)
				.order("episode_number")
				.execute()
				.value
			
			Analytics.capture(
				.success,
				id: "fetch_episodes",
				longDescription: "Fetched \(episodes.count) episodes for series \(seriesId)",
				source: .db
			)
			
			return episodes
		} catch {
			Analytics.capture(
				.error,
				id: "fetch_episodes",
				longDescription: "Error fetching episodes: \(error)",
				source: .db
			)
			throw error
		}
	}
}

//MARK: - User Library & Watch History
extension DB {
	/// Updates the user's watch history for a given series.
	/// Performs an upsert operation: inserts if no record exists, updates last_episode_id if it does.
	/// Sets is_saved to false when inserting a new record.
	@MainActor
	public func updateWatchHistory(userId: UUID, seriesId: UUID, lastEpisodeId: UUID) async {
		Analytics.capture(
			.info,
			id: "update_watch_history_called",
			longDescription: "User: \(userId), Series: \(seriesId), Episode: \(lastEpisodeId)",
			source: .db
		)

		let entry = UserLibraryEntry(
			userId: userId,
			seriesId: seriesId,
			lastEpisodeId: lastEpisodeId,
			isSaved: false // Default to false when tracking history, saving is explicit
		)

		do {
			// Perform an upsert. If conflict on (user_id, series_id), only update last_episode_id.
			// Note: Supabase client upsert defaults to ignoring duplicates if no onConflict is specified,
			// but we want to update the episode ID. Using `rpc` might be needed for precise control,
			// or rely on the Swift client's upsert behavior (needs verification if it supports targeted update on conflict).
			// Let's try the standard upsert first. Assuming the Swift client handles `onConflict` implicitly or we adjust later.
			// A simpler approach for now might be to just upsert the whole entry. If is_saved was true, this would reset it.
			// Let's use a more explicit RPC call for clarity and correctness.

			// Define the parameters for the RPC call
			struct UpsertParams: Encodable {
				let usr_id: UUID
				let ser_id: UUID
				let ep_id: UUID
			}
			let params = UpsertParams(usr_id: userId, ser_id: seriesId, ep_id: lastEpisodeId)

			// Create a function in Supabase SQL:
			/*
			 CREATE OR REPLACE FUNCTION upsert_watch_history(usr_id uuid, ser_id uuid, ep_id uuid)
			 RETURNS void
			 LANGUAGE plpgsql
			 AS $$
			 BEGIN
				 INSERT INTO public.user_library (user_id, series_id, last_episode_id, is_saved)
				 VALUES (usr_id, ser_id, ep_id, false)
				 ON CONFLICT (user_id, series_id)
				 DO UPDATE SET last_episode_id = EXCLUDED.last_episode_id;
			 END;
			 $$;
			*/
			// Assuming the above SQL function 'upsert_watch_history' exists in your Supabase project.
			try await _db.rpc("upsert_watch_history", params: params).execute()


			Analytics.capture(
				.success,
				id: "update_watch_history",
				longDescription: "Successfully upserted watch history for User: \(userId), Series: \(seriesId)",
				source: .db
			)
            
            // Post notification on success
            NotificationCenter.default.post(name: .didUpdateUserLibrary, object: nil)
            print("[DB] Posted didUpdateUserLibrary notification.")
            
		} catch {
			Analytics.capture(
				.error,
				id: "update_watch_history",
				longDescription: "Error upserting watch history for User: \(userId), Series: \(seriesId): \(error)",
				source: .db
			)
			// Handle or log the error appropriately
			print("Error updating watch history: \(error)")
		}
	}

	/// Fetches the combined library details (watched and saved) for a user.
	/// Can optionally filter by a specific series ID.
	@MainActor
	public func fetchUserLibraryDetails(userId: UUID, seriesId: UUID? = nil) async throws -> [UserLibraryDetail] {
		Analytics.capture(
			.info,
			id: "fetch_user_library_details_called",
			longDescription: "Fetching library for User: \(userId)\(seriesId == nil ? "" : ", Series: \(seriesId!)")",
			source: .db
		)

		struct Params: Encodable {
			let p_user_id: UUID
			let p_series_id: UUID?
		}
		let params = Params(p_user_id: userId, p_series_id: seriesId)

		do {
			let details: [UserLibraryDetail] = try await _db
				.rpc("get_user_library_details", params: params)
				.execute()
				.value

			Analytics.capture(
				.success,
				id: "fetch_user_library_details",
				longDescription: "Successfully fetched \(details.count) library entries for User: \(userId)",
				source: .db
			)
			return details
		} catch {
			Analytics.capture(
				.error,
				id: "fetch_user_library_details",
				longDescription: "Error fetching library details for User: \(userId): \(error)",
				source: .db
			)
			print("Error fetching user library details: \(error)")
			throw error // Rethrow the error to be handled by the caller
		}
	}
}

//MARK: - Auth
extension DB {
	/// Static flag to prevent multiple simultaneous anonymous sign-ins
	private static var isSigningInAnonymously = false
	
	/// Signs in anonymously if no session exists
	@MainActor
	public func signInAnonymouslyIfNeeded() async throws {
		Analytics.capture(.info, id: "check_anonymous_signin", source: .db)
		
		// Check if we already have a session
		if let session = try? await _db.auth.session {
			Analytics.capture(
				.info,
				id: "existing_session_found",
				longDescription: "User ID: \(session.user.id)",
				source: .db
			)
			self.currentUser = session.user
			self.authState = .signedIn
			return
		}
		
		// No session exists, sign in anonymously
		Analytics.capture(.info, id: "attempting_anonymous_signin", source: .db)
		
		do {
			let session = try await _db.auth.signInAnonymously()
			
			Analytics.capture(
				.success,
				id: "anonymous_signin",
				longDescription: "Created anonymous user with ID: \(session.user.id)",
				source: .db
			)
			
			self.currentUser = session.user
			self.authState = .signedIn
		} catch {
			Analytics.capture(
				.error,
				id: "anonymous_signin",
				longDescription: "Error during anonymous sign in: \(error)",
				source: .db
			)
			self.authState = .signedOut
			throw AuthKitError.anonymousSignInError
		}
	}
    
    /// Updates the current user's attributes (email, password, data).
    /// This is used to convert an anonymous user to a permanent user by setting an email,
    /// or to update details for an existing permanent user.
    @MainActor
    public func updateUser(attributes: UserAttributes) async throws {
        Analytics.capture(.info, id: "update_user_called", source: .db)
        do {
            try await _db.auth.update(user: attributes)
            // The auth state listener should automatically update self.currentUser
            Analytics.capture(.success, id: "update_user", source: .db)
        } catch {
            Analytics.capture(
                .error,
                id: "update_user",
                longDescription: "Error updating user: \(error.localizedDescription)",
                source: .db
            )
            // Handle specific Supabase errors if needed, otherwise rethrow generic error
            if let authError = error as? AuthError {
                 print("Supabase Auth Error updating user: \(authError)")
                 // Use existing error type from AuthKitError.swift
                 throw AuthKitError.catchAllError 
            } else {
                 // Use existing error type from AuthKitError.swift
                 throw AuthKitError.catchAllError 
            }
        }
    }
    
    /// Updates the current user's display name (full_name in user_metadata).
    @MainActor
    public func updateDisplayName(newName: String) async throws {
        Analytics.capture(.info, id: "update_display_name_called", source: .db)
        
        let trimmedName = newName.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmedName.isEmpty else {
            // Use .info for analytics when validation fails
            Analytics.capture(.info, id: "update_display_name_empty", source: .db)
            // Throw the custom validation error
            throw ValidationError(message: "Display name cannot be empty.")
        }
        
        // UserAttributes data expects a dictionary with AnyJSON values
        let attributes = UserAttributes(data: ["full_name": AnyJSON.string(trimmedName)])
        
        do {
            try await self.updateUser(attributes: attributes)
            Analytics.capture(.success, id: "update_display_name", source: .db)
            // Refresh session to ensure local currentUser data is updated immediately
            await self.refreshSession()
        } catch {
            Analytics.capture(
                .error,
                id: "update_display_name",
                longDescription: "Error updating display name: \(error.localizedDescription)",
                source: .db
            )
            // Rethrow the error caught by updateUser or the validation error
            throw error
        }
    }
}

// MARK: - Session Refresh
extension DB {
	/// Attempts to refresh the current user session.
	/// This is useful when the app becomes active to ensure the user state is up-to-date.
	@MainActor
	public func refreshSession() async {
		Analytics.capture(.info, id: "refresh_session_called", source: .db)
		do {
			_ = try await _db.auth.refreshSession()
			Analytics.capture(.success, id: "refresh_session", source: .db)
		} catch {
			Analytics.capture(
				.error,
				id: "refresh_session",
				longDescription: "Error refreshing session: \(error.localizedDescription)",
				source: .db
			)
			print("[DB] Error refreshing session: \(error.localizedDescription)")
			// Handle or surface the error if needed, though the auth listener might handle state changes anyway
		}
	}
}
